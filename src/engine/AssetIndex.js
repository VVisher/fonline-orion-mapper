/**
 * AssetIndex — runtime loader for JSON indexes generated by the indexer scripts.
 *
 * Loads tiles.json, critters.json, items.json, objects.json from source/database/.
 * Falls back gracefully if indexes don't exist yet.
 */

const DB_BASE = '/source/database';

class AssetIndex {
  constructor() {
    this.tiles = null;       // { categories: {}, all: [] }
    this.critters = null;    // { entries: [] }
    this.items = null;       // { entries: [] }
    this.objects = null;     // { entries: {} }  PID → { name, description }
    this.defines = null;     // { defines: {} }
    this._loaded = false;
    this._listeners = new Set();
  }

  get loaded() { return this._loaded; }

  /**
   * Load all available indexes. Safe to call multiple times.
   */
  async loadAll() {
    const results = await Promise.allSettled([
      this._fetch('tiles.json'),
      this._fetch('critters.json'),
      this._fetch('items.json'),
      this._fetch('objects.json'),
      this._fetch('defines.json'),
    ]);

    if (results[0].status === 'fulfilled') this.tiles = results[0].value;
    if (results[1].status === 'fulfilled') this.critters = results[1].value;
    if (results[2].status === 'fulfilled') this.items = results[2].value;
    if (results[3].status === 'fulfilled') this.objects = results[3].value;
    if (results[4].status === 'fulfilled') this.defines = results[4].value;

    this._loaded = true;
    this._notify();
  }

  /**
   * Get tile categories as { label, prefix, count }[].
   */
  getTileCategories() {
    if (!this.tiles?.categories) return [];
    return Object.entries(this.tiles.categories).map(([prefix, files]) => ({
      prefix,
      label: prefix,
      count: files.length,
      files,
    }));
  }

  /**
   * Get all tile paths for a given category prefix.
   */
  getTilesByCategory(prefix) {
    if (!this.tiles?.categories?.[prefix]) return [];
    return this.tiles.categories[prefix].map(f => `art\\tiles\\${f}`);
  }

  /**
   * Get all tile paths.
   */
  getAllTiles() {
    return this.tiles?.all || [];
  }

  /**
   * Search tiles by substring.
   */
  searchTiles(query) {
    const q = query.toLowerCase();
    return this.getAllTiles().filter(t => t.toLowerCase().includes(q));
  }

  /**
   * Get object name by PID from FOOBJ.MSG index.
   */
  getObjectName(pid) {
    return this.objects?.entries?.[String(pid)]?.name || null;
  }

  /**
   * Get object description by PID.
   */
  getObjectDescription(pid) {
    return this.objects?.entries?.[String(pid)]?.description || null;
  }

  subscribe(listener) {
    this._listeners.add(listener);
    return () => this._listeners.delete(listener);
  }

  async _fetch(fileName) {
    const url = `${DB_BASE}/${fileName}`;
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
    return resp.json();
  }

  _notify() {
    for (const fn of this._listeners) fn();
  }
}

// Singleton
export const assetIndex = new AssetIndex();
