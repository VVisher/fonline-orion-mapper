uint top = 1110, left = 0, bottom = 0, right = 1110;
uint offx, offy;
const uint[] CobblestoneRoadPids = {7869, 7870, 7871, 7872, 7873, 7874, 7875, 7876, 7877, 7878};
const uint[] roadPids = {2278,2279,2280};

const uint[] tirestackPids = {4973,4974,4975};

const uint[] roadStuff = {2224,2225,2226,2227,2228,4523,4522,4520,4521,4573,4574,7003,7004,7005,7006,7007};
const uint[][] roadSideStuffX = {{2291},{2294},{4602,2243,2257,2106,2315,2276}};
const uint[][] roadSideStuffY = {{2293},{2292},{2268,2269,2243,2106,2315,2276,3604}};


Placeholder[] dat;
class Placeholder
{
	int x;
	int y;
	int width;
	int height;
	int idx;
	int color;
	bool place = true;

	Placeholder ( int x, int y, int width, int height, int idx, int color)
	{
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		this.idx = idx;
		this.color = color;
	}

	Placeholder ( int x, int y, int width, int height, int color)
	{
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		this.place = false;
		this.color = color;
	}

	void Bully()
	{
		for (int i = 0, l = dat.length(); i < l ; i++)
			if ( dat[i].place && dat[i].CheckCollision(x,y,width,height) ) 
			{
				dat.removeAt(i--); 
				l--;
			}
	}

	void Draw()
	{
		int[] tris = {this.x, this.y, 0xFF000000,		
					this.x, this.y + this.height, this.color,
					this.x + this.width, this.y, this.color,
						this.x + this.width, this.y+this.height, this.color						
		};

		DrawPrimitive(DRAW_PRIMITIVE_TRIANGLESTRIP, tris);
	}

	bool CheckCollision(int x, int y, int width, int height)
	{
		if (this.x <= x + width &&
		   this.x + this.width >= x &&
		   this.y <= y + height &&
		   this.height + this.y >= y) 
		   return true;

		return false;
	}
}

int CheckCollision(int x, int y, int width, int height)
{
	for (int i = 0, l = dat.length(); i < l ; i++)
		if ( dat[i].CheckCollision(x,y,width,height) ) 
			return i;

	return -1;
}

void CachePrefab(uint16 x, uint16 y, uint idx, int& width, int& height)
{
	x -= PrefabList[idx].width / 2 ;
	y -= PrefabList[idx].height / 2 ;
	if ( x & 0x1 > 0 && PrefabList[idx].offsetx == 1 )
		x += 1;

	if ( x & 0x1 == 0 && PrefabList[idx].offsetx == 2 )
		x += 1;

	width = PrefabList[idx].width;
	height = PrefabList[idx].height;	

	if ( CheckCollision( x,y,width, height ) < 0 )
		dat.insertLast( Placeholder(x,y,width,height,idx, 0xFFFF0000));
	else
		Message("Collide");
}

void PlacePrefab(MapperMap@ map, int x, int y, int idx)
{	
	x += PrefabList[idx].adjustx;
	y += PrefabList[idx].adjusty;
	
	if ( x & 0x1 > 0 && PrefabList[idx].offsetx == 1 )
		x += 1;		 	

	if ( x & 0x1 == 0 && PrefabList[idx].offsetx == 2 )
		x += 1;

	PrefabList[idx].originX = x;
	PrefabList[idx].originY = y;

	for (uint i = 0, l = PrefabList[idx].data.length(); i < l; i+=3)		
	{
		uint tx = x - PrefabList[idx].data[i]; 
		uint ty = y - PrefabList[idx].data[i+1];

		MapperObject@ obj = map.AddObject(tx , ty, MAP_OBJECT_SCENERY, PrefabList[idx].data[i+2]);
		if ( valid(obj))
			obj.UserData0 = idx;
	}
}

string sb(string str)
{
	lp(str);
	MapperMap@ map = GetActiveMap();
	if (!valid(map))
		return "";
	
	dat.set_length(0);
	array<MapperObject@> objects;
	int l=map.GetObjects(1,1,10000,MAP_OBJECT_SCENERY,3853,objects);
	int counter = 0;
	for (uint i=0; i<l; i++)
	{		
		if (objects[i].Scenery_ToEntire == 99999)
		{
			offx = objects[i].MapX;
			offy = objects[i].MapY;
		}
	}
    for (uint i=0; i<l; i++)
    {		
		if (objects[i].Scenery_ToEntire == 99999)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			drawdata.insertLast(x);
			drawdata.insertLast(y);
			drawdata.insertLast(0xFFFF0000);
			Hex2Square(x,y,offx,offy);  
			left = x;
			top = y;		
		}
		else if (objects[i].Scenery_ToEntire == 99998)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;				
			drawdata.insertLast(x);
			drawdata.insertLast(y);
			drawdata.insertLast(0xFF00FF00);
			Hex2Square(x,y,offx,offy);  
			right = x;
			bottom = y;		
		}
		else if (objects[i].Scenery_ToEntire == 99997)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			drawdata.insertLast(x);
			drawdata.insertLast(y);
			drawdata.insertLast(0xFF0000FF);
			Hex2Square(x,y,offx,offy);   		
		}
		else if (objects[i].Scenery_ToEntire == 99996)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			drawdata.insertLast(x);
			drawdata.insertLast(y);
			drawdata.insertLast(0xFFFFFFFF);
			Hex2Square(x,y,offx,offy);  			
		}
	}

	//uint16 ox = Random(0, left * 2);
	//uint16 oy = Random(top, bottom  * 2 / 3);

	//uint16 tx = Random(0, left * 2);
	//uint16 ty = Random(top, bottom  * 2 / 3);
	uint16 oxx = 0;
	uint16 oyy = Random(top + bottom / 2 , bottom);

	
	Square2Hex(oxx,oyy,offx,offy);
	
	int ox = oxx;
	int oy = oyy;

	Message(ox + " " + oy );
	//Square2Hex(tx,ty,offx,offy)p
	
	int  dist;
	for (uint it = 0; it < 2; it++)
	{	
		int tx = ox;
		int ty = oy;

		bool mode = (it & 1 == 0);

		if ( mode )
		{			
			tx += 200;
			ox -= 200;			
		}
		else
		{

			switch ((Random(0,2)))
			{
				case 0:
					ty += 200;
					break;
				case 1:
					oy -= 200;
					break;
				case 2:
					ty += 200;
					oy -= 200;
					break;
			}
		}
	
		tx = CLAMP(tx, 0,map.Width);
		ox = CLAMP(ox, 0,map.Width);
		ty = CLAMP(ty, 0,map.Height);
		oy = CLAMP(oy, 0,map.Height);


		array<uint> data;
		dist = GetDistantion(ox, oy, tx, ty);
	
		Trace(ox,oy,tx,ty, dist, data);	
	
		uint buffer = 5;
		uint nbuffer = 35;
		uint lotsize = 20;
		for (uint i = 0, l = data.length(); i < l;)
		{	
			map.AddObject( data[i],data[i+1], MAP_OBJECT_SCENERY, RandomA(CobblestoneRoadPids));
			i+= Random(10,20) * 2;		
		}
		
		//House 
		for (uint i = Random(25,30) * 2, l = data.length(); i < l ; i+= Random(5,10) * 2)	
		{
			int width = 0, height = 0;

			CachePrefab( data[i] + buffer + lotsize , data[i+1] + buffer  + lotsize , Random(0, PrefabList.length() - 1 ), width , height);
	
		/*	for (uint x = 0; x < lotsize; x++)
				for (uint y = 0; y < lotsize; y++)
					map.AddObject( data[i] + buffer + x,data[i+1] + buffer + y, MAP_OBJECT_SCENERY, RandomA(roadPids));		*/

			if ( mode ) 
				i += width * 2;
			else
				i += height * 2;
		}		

		for (uint i = Random(25,30) * 2, l = data.length(); i < l ; i+= Random(5,10) * 2)	
		{
			int width = 0, height = 0;

			CachePrefab( data[i] - nbuffer - lotsize  , data[i+1] - nbuffer - lotsize  , Random(0, PrefabList.length() - 1 ), width , height);
		//	PlacePrefab(map, data[i] - nbuffer - lotsize , data[i+1] - nbuffer - lotsize , Random(0, PrefabList.length() - 1 ));
		/*	for (uint x = 0; x < lotsize; x++)
				for (uint y = 0; y < lotsize; y++)
					map.AddObject( data[i] - nbuffer - x,data[i+1] - nbuffer - y, MAP_OBJECT_SCENERY, RandomA(roadPids));*/

			if ( mode ) 
				i += width * 2;
			else
				i += height * 2;
		}

		// Road
		for (uint i = Random(5,50) * 2, l = data.length(); i < l ; i+= Random(5,50) * 2)
		{
			if ( mode )
				map.AddObject( data[i] , data[i+1] - Random(0,20) , MAP_OBJECT_SCENERY, RandomA(roadStuff));
			else
				map.AddObject( data[i] - Random(0,20), data[i+1]  , MAP_OBJECT_SCENERY, RandomA(roadStuff));
		}

		// Road Lamps
		for (uint i = 0, l = data.length(); i < l ; i+= Random(1,3) * 20 * 2)
		{
			if ( mode )
				map.AddObject( data[i] , data[i+1], MAP_OBJECT_SCENERY, RandomA(roadSideStuffX[0]));
			else
				map.AddObject( data[i] , data[i+1], MAP_OBJECT_SCENERY, RandomA(roadSideStuffY[0]));
		}
		// Road Lamps otherside
		for (uint i = 0, l = data.length(); i < l ; i+= Random(1,3) * 20 * 2)
		{
			if ( mode )
				map.AddObject( data[i] , data[i+1] - 25, MAP_OBJECT_SCENERY, RandomA(roadSideStuffX[1]));
			else
				map.AddObject( data[i] - 25 , data[i+1], MAP_OBJECT_SCENERY, RandomA(roadSideStuffY[1]));
	
		}
		// Roadsidewalk shit
		for (uint i = Random(1,3) * 20 * 2, l = data.length(); i < l ; i+= Random(1,3) * 20 * 2)
		{
			if ( mode )
				map.AddObject( data[i], data[i+1] + 3, MAP_OBJECT_SCENERY, RandomA(roadSideStuffX[2]));
			else
				map.AddObject( data[i] + 3  , data[i+1] , MAP_OBJECT_SCENERY, RandomA(roadSideStuffY[2]));
		}
		for (uint i =  Random(1,3) * 20 * 2, l = data.length(); i < l ; i+= Random(1,3) * 20 * 2)
		{
			if ( mode )
				map.AddObject( data[i] , data[i+1] - 28, MAP_OBJECT_SCENERY, RandomA(roadSideStuffX[2]));
			else
				map.AddObject( data[i] - 28 , data[i+1], MAP_OBJECT_SCENERY, RandomA(roadSideStuffY[2]));
		}			

		int rw = abs(ox - tx) + (mode ? 0 : nbuffer );
		int rh =  abs(oy - ty) + (mode ? nbuffer : 0);
				
		dat.insertLast( Placeholder(ox -(mode ? 0 : nbuffer )  ,oy - (mode ? nbuffer  : 0) , rw, rh, 0xFFFFFFFF));
		dat.last().Bully(); //pls no

		//Guideline
	/*	for (uint i = 0, l = data.length(); i < l ; i+= 2)
			map.AddObject( data[i],data[i+1], MAP_OBJECT_SCENERY, RandomA(roadPids));*/

		int r = Random(0,dist);
		ox = data[r*2];
		oy = data[r*2 +1];		
	}

	for (uint i = 0, l = dat.length(); i < l ; i++)
		if (dat[i].place)
			PlacePrefab(map, dat[i].x , dat[i].y,  dat[i].idx );

	return "";
}


const uint[][] treePids = {{23000,23001,23002,23003,23004},
							{23005,23006,23007,23008,23009,23010,23011,23012,23013,23014},
							{23015,23016},
							{23017,23018,23019},
							{23020,23021,23022,23023},
							{23024,23025,23026,23027},
							{23028,23029,23030,23031,23032},
							{23033,23034,23035,23036,23037,23038,23039},
							{23033,23034,23035,23036,23037,23038,23039},
							{23040,23041,23042,23043,23044,23045}};

const uint[] minedoodads = { 3152, 3629, 2648, 2904, 2275 };
const uint[] rocksPids= {9148,9149,2407,4243,4242};

string m(string str)
{
	MapperMap@ map = GetActiveMap();
	if (!valid(map))
		return "";
	
	dat.set_length(0);
	array<MapperObject@> objects;
	int l=map.GetObjects(1,1,10000,MAP_OBJECT_SCENERY,3853,objects);
	for (uint i=0; i<l; i++)
	{		
		if (objects[i].Scenery_ToEntire == 99999)
		{
			offx = objects[i].MapX;
			offy = objects[i].MapY;
		}
	}
    for (uint i=0; i<l; i++)
    {		
		if (objects[i].Scenery_ToEntire == 99999)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			Hex2Square(x,y,offx,offy);  
			left = x;
			top = y;		
		}
		else if (objects[i].Scenery_ToEntire == 99998)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			Hex2Square(x,y,offx,offy);  
			right = x;
			bottom = y;		
		}
		else if (objects[i].Scenery_ToEntire == 99997)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			Hex2Square(x,y,offx,offy);   		
		}
		else if (objects[i].Scenery_ToEntire == 99996)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			Hex2Square(x,y,offx,offy);  			
		}
	}
	
	//for (uint y = top; y <= bottom; y++)
	//{
	//	for (uint x = 0; x <= right; x++)
	//	{
	//		uint16 ox = x, oy = y;			
	//		if ( y == top || y == bottom || x == 0 || x == right )
	//		{
	//			if ( Square2Hex(ox,oy,offx,offy) )				
	//			{
	//				MapperObject@ obj = map.AddObject( ox , oy , MAP_OBJECT_SCENERY, 2067);
	//			}			
	//		}
	//	}
	//}

	// Draw forest

	
	for (uint y = top; y <= bottom; y++)
	{
		for (uint x = left; x <= right  ; x++)
		{
			float maxX = bottom;// / 2;// / 3;
			float progress = float (y - (maxX / 2)) / maxX ;

			uint16 ox = x, oy = y;						
			if ( Random(0,10000) < (progress * 700) && Square2Hex(ox,oy,offx,offy) )				
			{
				MapperObject@ obj = map.AddObject( ox , oy , MAP_OBJECT_SCENERY, RandomA(treePids[0]));
			}						
		}
	}

	{
		uint16 ox = right / 5;
		uint16 oy = (top + bottom) / 2;		
		Square2Hex(ox,oy,offx,offy);
		array<MapperObject@> objects;
		int l=map.GetObjects(ox,oy,10,MAP_OBJECT_SCENERY,0,objects);
		DeleteObjects(objects);
	}

	for (uint i = 0; i < 5; i++)
	{
		uint16 ox = right / 5;
		ox += (Random(0,1) == 0) ? Random(5,10): -Random(5,10);
		uint16 oy = (top + bottom) / 2;		
		oy += (Random(0,1) == 0) ? Random(5,10): -Random(5,10);
		Square2Hex(ox,oy,offx,offy);
		MapperObject@ obj = map.AddObject( ox , oy , MAP_OBJECT_SCENERY, RandomA(minedoodads));
	}
	{
		uint16 ox = right / 5;
		uint16 oy = (top + bottom) / 2;	
		Square2Hex(ox,oy,offx,offy);
		MapperObject@ obj = map.AddObject( ox , oy , MAP_OBJECT_SCENERY, 3684);
	}
	

	// Draw forestlanes
	/*for (uint y = top; y <= bottom / 5; y++)
	{
		for (uint x = right/9 ; x <= right / 9 * 8 ; x++)
		{
			uint16 ox = x, oy = y;						
			if ( Random(0,10000) < (500) && Square2Hex(ox,oy,offx,offy) )				
			{
				MapperObject@ obj = map.AddObject( ox , oy , MAP_OBJECT_SCENERY, RandomA(treePids[1]));
			}						
		}
	}

	for (uint y = bottom / 5 * 4 ; y <= bottom; y++)
	{
		for (uint x = right/9 ; x <= right / 9 * 8 ; x++)
		{
			uint16 ox = x, oy = y;						
			if ( Random(0,10000) < (500) && Square2Hex(ox,oy,offx,offy) )				
			{
				MapperObject@ obj = map.AddObject( ox , oy , MAP_OBJECT_SCENERY, RandomA(treePids[1]));
			}						
		}
	}*/

	//for (uint y = bottom / 5 ; y <= bottom / 5 * 4; y++)
	//{
	//	for (uint x = right/4 ; x <= right / 4 * 3 ; x++)
	//	{
	//		uint16 ox = x, oy = y;						
	//		if ( Random(0,10000) < (10) && Square2Hex(ox,oy,offx,offy) )				
	//		{
	//			MapperObject@ obj = map.AddObject( ox , oy , MAP_OBJECT_SCENERY, RandomA(rocksPids));
	//		}						
	//	}
	//}
	//Lane 1 
	{
		uint16 ox = 0 , oy = bottom / 6 * 4 , tx = right;		
		array<uint> data;
		uint16 ty = oy;
		Square2Hex(ox,oy,offx,offy);
		Square2Hex(tx,ty,offx,offy);
		int dist = GetDistantion(ox, oy, tx, ty);
		Trace(ox,oy,tx,ty, dist, data);	
		for (uint i =0, l = data.length(); i < l ; i+=2)
		{
			map.AddObject( data[i] , data[i+1], MAP_OBJECT_SCENERY, RandomA(roadPids));
		}
	}

	{
		uint16 ox = 0 , oy = bottom / 6 * 2 , tx = right;		
		array<uint> data;
		uint16 ty = oy;
		Square2Hex(ox,oy,offx,offy);
		Square2Hex(tx,ty,offx,offy);
		int dist = GetDistantion(ox, oy, tx, ty);
		Trace(ox,oy,tx,ty, dist, data);	
		for (uint i =0, l = data.length(); i < l ; i+=2)
		{
			map.AddObject( data[i] , data[i+1], MAP_OBJECT_SCENERY, RandomA(roadPids));
		}
	}
	
	return "" + left + " " + right + " " + top + " " + bottom;
}

//Cave Generation


const uint[] mineralsPids = {13301}; // Rare 4233, 4234,
const uint[] caveWall = {23046, 23047, 23048, 23049};

void CaveFill(MapperMap@ map, uint16 x, uint16 y, uint16 fx, uint16 fy, bool[][]& dat)
{
	if ( x != fx || y != fy )
	{
		MapperObject@ exist = map.GetObject(x,y, MAP_OBJECT_SCENERY, 0, 0);
		if (valid(exist))
			return;

		if ((dat[x][y]))
			return;
	}

	int dist = GetDistantion(x, y, fx, fy);
	int pathdist = GetPathLength(x, y, fx, fy, 0);

	if (dist != pathdist)
		return;

	dat[x][y] = true;	
	//MapperObject@ entire = map.AddObject( x, y, MAP_OBJECT_SCENERY, RandomA(caveWall));
	
	for (uint i =0 ; i < 6; i++)
	{
		uint16 ox = x;
		uint16 oy = y;
		MoveHexByDir(ox,oy,i,1);
		CaveFill(map, ox,oy, x, y, dat);
	}	

}

string c(string str)
{
	MapperMap@ map = GetActiveMap();
	if (!valid(map))
		return "";
	
	array<MapperObject@> objects;
	int l=map.GetObjects(1,1,10000,MAP_OBJECT_SCENERY,3853,objects);
	int counter = 0;
	for (uint i=0; i<l; i++)
	{		
		if (objects[i].Scenery_ToEntire == 99999)
		{
			offx = objects[i].MapX;
			offy = objects[i].MapY;
		}
	}
	uint fillx, filly;
    for (uint i=0; i<l; i++)
    {	
		if (objects[i].Scenery_ToEntire == 0)
		{
			fillx = objects[i].MapX;
			filly = objects[i].MapY;
			
		}
		else if (objects[i].Scenery_ToEntire == 99999)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;

			Hex2Square(x,y,offx,offy);  
			left = x;
			top = y;
			
			drawdata.insertLast(x);
			drawdata.insertLast(y);
			drawdata.insertLast(0xFFFF0000);
		}
		else if (objects[i].Scenery_ToEntire == 99998)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			Hex2Square(x,y,offx,offy);  
			right = x;
			bottom = y;
			
			drawdata.insertLast(x);
			drawdata.insertLast(y);
			drawdata.insertLast(0xFF00FF00);
		}
		else if (objects[i].Scenery_ToEntire == 99997)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			Hex2Square(x,y,offx,offy);   
			drawdata.insertLast(x);
			drawdata.insertLast(y);
			drawdata.insertLast(0xFF0000FF);
		}
		else if (objects[i].Scenery_ToEntire == 99996)
		{
			uint16 x, y;
			x = objects[i].MapX;
			y = objects[i].MapY;
			Hex2Square(x,y,offx,offy);  
			drawdata.insertLast(x);
			drawdata.insertLast(y);
			drawdata.insertLast(0xFFFFFFFF);
		}
	}

	objects.set_length(0);

	array<array<bool>> MapDat(map.Width, array<bool>(map.Height));

	for (uint y = 0; y < map.Height; y++)
		for (uint x = 0; x < map.Width; x++)
			MapDat[x][y] = false;
	
	//array<array<MapperObject@>> MapDat(map.Width, array<MapperObject@>(map.Height));
	
	CaveFill(map, fillx, filly, fillx, filly, MapDat);

	for (uint y = 0; y < map.Height; y++)
		for (uint x = 0; x < map.Width; x++)
			if (MapDat[x][y])
			{
				MapperObject@ obj = map.AddObject( x , y , MAP_OBJECT_SCENERY, RandomA(caveWall));
				obj.UserData1 = x;
				obj.UserData2 = y;
				if (Random(0,100) == 0)
				{
					obj.UserData0 = Random(0,0xFF);
					objects.insertLast(obj);
				}
			}

	/*for (uint y = 0; y < map.Height; y++)
	{
		for (uint x = 0; x < map.Width; x++)
		{
			uint16 ox = x, oy = y;
			if ( Hex2Square(ox,oy,offx,offy) )
				if ( ox > 0 && ox <= right && oy > top  && oy <= bottom )
				{
					MapperObject@ obj = map.AddObject( x , y , MAP_OBJECT_SCENERY, 2067);
				}
		}
	}*/
	
	//for (uint x = 2 , mx =  right ; x < mx; x++)
	//	for (uint y= top + 2, my = bottom ; y < my  ; y++)
	//	{
	//		/*if (x == 0 || x  ==  mx - 1 || y == top || y == my - 1)
	//		{		*/
	//			uint16 ox = x, oy = y;

	//			Square2Hex(ox,oy,offx,offy);
	//			MapperObject@ obj = map.AddObject( ox,oy, MAP_OBJECT_SCENERY, 2067);
	//			obj.UserData1 = x;
	//			obj.UserData2 = y;
	//			if (Random(0,100) == 0)
	//			{
	//				obj.UserData0 = Random(0,0xFF);
	//				objects.insertLast(obj);
	//			}
	//		//}
	//	}

	for (uint i = 0, l = objects.length(); i < l; i++)
	{
		array<MapperObject@> propObj;
		uint count = map.GetObjects(objects[i].MapX, objects[i].MapY, sqrt(objects[i].UserData0), MAP_OBJECT_SCENERY, 0 , propObj);
		
		for (uint k = 0; k < count; k++)
		{
			if ( Random(0,100) > 66 )
				continue;

			propObj[k].UserData0 = Random(objects[i].UserData0 / 2, objects[i].UserData0);			
		}
	}
	drawdata2.set_length(0);
	objects.set_length(0);
	int count = 0;
	for (uint i = 0; i < caveWall.length(); i++)
	{
		count += map.GetObjects(0, 0, 100000, MAP_OBJECT_SCENERY, caveWall[i] , objects);
	}

	for (uint i = 0; i < objects.length(); i++)
	{	
		drawdata2.insertLast(objects[i].UserData1);
		drawdata2.insertLast(objects[i].UserData2);
		drawdata2.insertLast( 0xFF000000 + (objects[i].UserData0 << 16 ));
	}
	
	//RefreshMap();
	return "";
	
}

string d(string str)
{
	MapperMap@ map = GetActiveMap();
	if (!valid(map))
		return "";

    Area mapArea = GetMapMainArea(map);
    int offX = mapArea.Offx;
    int offY = mapArea.Offy;

    Message("offset " + offX + " " + offY);

    for (uint i = 0; i < 500; i++)
    {
        uint16 x = 50;
        uint16 y = i;

        Square2Hex(x, y, offX, offY);
        
        if (x < map.Width && y < map.Height)
            map.AddObject(x, y, MAP_OBJECT_SCENERY, 3853);
    }
    
    return "";
}

string e(string str)
{
	MapperMap@ map = GetActiveMap();
	if (!valid(map))
		return "";

	string@[] vals = split(str," ");	

	int hexX = 0;
	int hexY = 0;
    if (vals.length() < 2 || !StrToInt(vals[0], hexX) || !StrToInt(vals[1], hexY))
		return "error";

    Area mapArea = GetMapMainArea(map);
    int offX = mapArea.Offx;
    int offY = mapArea.Offy;

    Message("offset " + offX + " " + offY);
    
    uint16 x = hexX;
    uint16 y = hexY;
    if (!Hex2Square(x, y, offX, offY))
        return "bad xy";
    
    return x + " " + y;
}

int hob (uint n) 
{
    n |= (n >>  1);
    n |= (n >>  2);
    n |= (n >>  4);
    n |= (n >>  8);
    n |= (n >> 16);
    return n - (n >> 1);
}

array<int> drawdata = {};
array<int> drawdata2 = {};
void RefreshMap()
{
	MapperMap@ map = GetActiveMap();
	if (!valid(map))
		return;
	drawdata2.set_length(0);
	array<MapperObject@> objs;
	for (uint i=0, l=map.GetObjects(1,1,10000,MAP_OBJECT_SCENERY,13301,objs); i<l; i++)
    {
		drawdata2.insertLast(objs[i].MapX);
		drawdata2.insertLast(objs[i].MapY);
		drawdata2.insertLast(0xFFFFFFFF);
	}
}

void DrawMap()
{
	DrawPrimitive(DRAW_PRIMITIVE_POINTLIST, drawdata2);
	for (uint i = 0, l = dat.length(); i < l ; i++)
		dat[i].Draw();
//	DrawPrimitive(DRAW_PRIMITIVE_LINELIST, drawdata);	
}
bool Square2Hex(uint16& x, uint16& y, uint offx, uint offy)
{
	int hexX = offx - x/2 + (y+1)/2;
	int hexY = offy +  x/4 + (3*y)/4;

	if (hexX < 0)
		return false;
	if (hexY < 0)
		return false;

	x = hexX;
	y = hexY;
	return true;
}

bool Hex2Square(uint16& HexX, uint16& HexY, uint offx, uint offy)
{
	int y = (HexX + 2 * HexY - offx - 2 * offy) / 2;
	int x = 4 * HexY - 3 * y - 4 * offy;

	if (x < 0)
		return false;
	if (y < 0)
		return false;

	HexX = x;
	HexY = y;
	return true;
}

bool Hex2Square(float& HexX, float& HexY, uint offx, uint offy)
{
	float y = (HexX + 2 * HexY - offx - 2 * offy) / 2;
	float x = 4 * HexY - 3 * y - 4 * offy;


	HexX = x;
	HexY = y;
	return true;
}

/*
Width & Height x 2 + 4

Offset X = 0 + Width + 1
Offset Y = 0 + Height + 1
*/
string CenterShit(string str)
{
	MapperMap@ map = GetActiveMap();
	if (!valid(map))
		return "";

	return "";
}


// test data below

class Area
{
	int x;
    int y;
    int mx;
    int my;
	int Offx;
	int Offy;
	//clearly i fucked up and x = right, mx = left for some fucking reason.
	Area(uint x, uint y, uint mx, uint my, uint offx, uint offy)
	{
		this.x = x;
		this.y = y;
		this.mx = mx;
		this.my = my;
		this.Offx = offx;
		this.Offy = offy;
	}

	bool GetRandomHex(uint16& x, uint16& y, int margin = 7 )
	{
		x = Random( this.x - margin, this.mx + margin );	
		y = Random( this.y + margin, this.my - margin );
		return Square2Hex(x,y, this.Offx, this.Offy);
	}

	bool GetRandomPerimeterHex(uint16& x, uint16& y)
	{
		switch (Random(0, 3))
		{
			case 0:
				x = Random(this.x, this.mx);
				y = Random(this.y + 7 , this.y + 10);
				break;
			case 1:
				x = Random(this.x, this.mx);
				y = Random(this.my -10, this.my - 7);
				break;

			case 2:
				x = Random(this.x - 10 , this.x - 7);
				y = Random(this.y, this.my);
				break;
			case 3:
				x = Random(this.mx + 7 , this.mx + 10);
				y = Random(this.y, this.my);
				break;
		}
		return Square2Hex(x,y, this.Offx, this.Offy); 
	}

	Area getTop()
	{
		return Area(this.x, this.y, this.mx, this.my / 2, this.Offx, this.Offy);
	}

	Area getBottom()
	{
		return Area(this.x, this.my / 2, this.mx, this.my, this.Offx, this.Offy);
	}

	Area getLeft()
	{	
		return Area(this.x / 2, this.y, this.mx, this.my, this.Offx, this.Offy);
	}

	Area getRight()
	{
		return Area(this.x / 2, this.y, this.x , this.my, this.Offx, this.Offy);
	}

	void dump()
	{
		Log(this.x + " x # " +
			this.y + " y # " +
			this.mx + " mx # " +
			this.my + " my # " +
			this.Offx + " offx # " +
			this.Offy + " offy");
	}
}

class TRect
{
    int x;
    int y;
    int mx;
    int my;
	int Offx;
	int Offy;

	bool Inside(uint x, uint y)
	{
		if ( x < this.mx )
			return false;

		if ( x > this.x )
			return false;

		if ( y < this.y )
			return false;

		if ( y > this.my)
			return false;

		return true;
	}

	TRect(uint x, uint y, uint mx, uint my)
	{
		this.x = x;
		this.y = y;
		this.mx = mx;
		this.my = my;
	}

	TRect(uint x, uint y, uint mx, uint my, uint offx, uint offy)
	{
		this.x = x;
		this.y = y;
		this.mx = mx;
		this.my = my;
		this.Offx = offx;
		this.Offy = offy;
	}

	TRect SubsectionSquare(uint X, uint Y)
	{
		uint anchorX = Random( this.mx, this.x ); 	
		uint anchorY = Random(  this.y, this.my);
		return TRect( anchorX	 , anchorY, MIN(this.x , anchorX + X), MIN(this.my, anchorY + Y), Offx, Offy);
	}		

	void Divide(array<TRect@>& input)
	{
		int centerX = (this.mx + this.x ) / 2;
		int centerY = (this.y + this.my ) / 2;
		if ( Random(0,1) == 0 )
		{			
			input.insertLast( TRect( this.mx	 , this.y, centerX, this.my  ));
			input.insertLast( TRect( centerX , this.y,  this.x , this.my  ));
		}
		else
		{
			input.insertLast( TRect( this.mx , this.y, this.x, centerY ));
			input.insertLast( TRect( this.mx , centerY, this.x,  this.my ));
		}		
	}

	void Quad(array<TRect@>& input)
	{
		int centerX = (this.mx + this.x ) / 2;
		int centerY = (this.y + this.my ) / 2;

		input.insertLast( TRect( this.mx , this.y, centerX, centerY)); // y mx

		input.insertLast( TRect( centerX , this.y,  this.x , centerY )); // y x

		input.insertLast( TRect( this.mx  , centerY,  centerX , this.my )); // my mx

		input.insertLast( TRect( centerX , centerY,  this.x , this.my )); // my x
	}

};

Area GetSquareBorders(uint startX, uint startY, uint endX, uint endY)
{
	uint16 mx = endX;
    uint16 my = endY;	
	Hex2Square(mx, my, startX, startY);

	return Area(mx, 0, 0, my, startX, startY);
}

Area GetMapMainArea(MapperMap& map)
{
    uint16 maxX = map.Width - 1;
    uint16 maxY = map.Height - 1;
    
    uint16 x1, y1;
    uint16 x2, y2;

    uint16 startX, startY;
    uint16 hexX, hexY;
    float angle;
    
    startX = (map.Width - 1) / 2;
    startY = (map.Height - 1) / 2;
    hexX = map.Width - 1;
    hexY = 0;
    angle = 15.0f;
    GetHexCoord(startX, startY, hexX, hexY, angle, 9999);
    
    startX = hexX;
    startY = hexY;
    hexX = map.Width - 1;
    hexY = 0;
    angle = -60.0f;
    GetHexCoord(startX, startY, hexX, hexY, angle, 9999);
    x1 = hexX;
    y1 = hexY;

    startX = hexX;
    startY = hexY;
    hexX = (map.Width - 1) / 2;
    hexY = (map.Height - 1) / 2;
    angle = 0;
    GetHexCoord(startX, startY, hexX, hexY, angle, 9999);
    x2 = hexX;
    y2 = hexY;

    return GetSquareBorders(x1, y1, x2, y2);
}
